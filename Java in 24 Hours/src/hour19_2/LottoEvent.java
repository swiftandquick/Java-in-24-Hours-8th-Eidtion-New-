package hour19_2;

import javax.swing.*;
import java.awt.event.*;


/* This class has codes that can make the LottoMadness' components interactive.  */
public class LottoEvent implements ActionListener, ItemListener, Runnable {
	
	/* Creates a LottoMadness object called gui.  */
	LottoMadness gui;
	
	/* Creates a thread.  */
	Thread playing;
	
	
	/* Creates a LottoEvent that passes the LottoMadness object gui to it. Then, set
	 * gui equal to the object argument from the parameter. */
	LottoEvent(LottoMadness in) {
		gui = in;
	}
	
	
	/* This method is generated by ActionListener, I can make the three buttons
	 * (Play, Stop, Reset) interactive through mouse clicks via this method.  */
	@Override
	public void actionPerformed(ActionEvent event) {
		/* Set command equal to the associated String of component that's being clicked.
		 * So it should get one of the three buttons' associated text. */
		String command = event.getActionCommand();
		/* Each button will invoke a different method.  */
		if (command.equalsIgnoreCase("Play")) {
			startPlaying();
		}
		if (command.equalsIgnoreCase("Stop")) {
			stopPlaying();
		}
		if (command.equalsIgnoreCase("Reset")) {
			clearAllFields();
		}
	}
	
	
	/* Method invoke by clicking "Play".  */
	public void startPlaying() {
		/* Creates a new Thread, then Thread calls the start() method to invoke the run() method.  */
		playing = new Thread(this);
		playing.start();
		
		/* The JButton play is set to false. Also, notice how I put "gui" in front of
		 * "play", that's because the component "play" is not in this class, but rather
		 * it's associated with the LottoMadness object called gui, which is equate to
		 * the object I created in the LottoMadness class.  */
		gui.play.setEnabled(false);
		
		/* When the Thread runs, naturally I want stop to become an enabled option.   */
		gui.stop.setEnabled(true);
		
		/* Reset button should be disabled because Thread is currently running.  */
		gui.reset.setEnabled(false);
		
		/* Disable the check boxes while the lottery is playing as well.  */
		gui.quickpick.setEnabled(false);
		gui.personal.setEnabled(false);	
		
		/* Speed shouldn't be able to change during drawing process.  */
		gui.speed.setEnabled(false);
		
		/* Disable all numbers field.  */
		for (int i = 0; i < 6; i++) {
			gui.numbers[i].setEnabled(false);
		}
		
	}
	
	
	/* Method invoke by clicking "Stop".  */
	public void stopPlaying() {
		/* When I stopped the lottery game, I shouldn't be able to click on the stop
		 * button until I start playing the game again.  */
		gui.stop.setEnabled(false);
		
		/* Re-enable everything else once the game is stopped.  */
		gui.play.setEnabled(true);
		gui.reset.setEnabled(true);
		gui.quickpick.setEnabled(true);
		gui.personal.setEnabled(true);
		gui.speed.setEnabled(true);
		
		/* Set all numbers field to editable.  */
		for (int i = 0; i < 6; i++) {
			gui.numbers[i].setEnabled(true);
		}
		
		/* Most importantly, when the game stops, the Thread should stop as well.  */
		playing = null;
	}
	
	
	/* Method invoke by clicking "Reset".  */
	public void clearAllFields() {
		/* Set all text fields back to what they are.  */
		for (int i = 0; i < 6; i++) {
			gui.numbers[i].setText(null); // Empty text field.  
			gui.winners[i].setText(null); // Empty text field.  
		}
		gui.got3.setText("0");
		gui.got4.setText("0");
		gui.got5.setText("0");
		gui.got6.setText("0");
		gui.drawings.setText("0");
		gui.years.setText("0");
	}
	
	
	/* This method is generated by ItemListener, it's used to create events for 
	 * interacting with (mouse clicks) with check boxes.  */
	@Override
	public void itemStateChanged(ItemEvent event) {
		/* Try to get the current item that is selected.  */
		Object item = event.getItem();
		/* If the retrieved object from parameter is equal to quickpick object (component).  */
		if (item == gui.quickpick) {
			/* Iterate for loop 6 times, each time adds a random number to to "numbers"
			 * JTextField. In quickpick, the six JTextField retrieve six respective
			 * automatically generated integers assigned to them. Basically, the computer
			 * choose 6 random valid numbers for me rather than I manually pick them myself. */
			for (int i = 0; i < 6; i++) {
				int pick;
				/* The do-while loop is to prevent the computer from automatically placing the
				 * same numbers in numbers JTextFields, because lottery numbers can't be the same.  
				 * For more information, check out the numberGone() method. */
				do {
					/* Picks a random integer from 1 to 50.  */
					pick = (int) Math.floor(Math.random() * 50 + 1);
				} while (numberGone(pick, gui.numbers, i));
				/* Adds the random integer to the one of the six "numbers" JTextField.  */
				gui.numbers[i].setText(Integer.toString(pick));
			}
		}
		/* I only have top check box options, and due to the being grouped into
		 * ButtonGroup, I can only choose one or the other. If quickpick isn't picked, 
		 * then personal is. The code below will execute if the checked check box 
		 * is personal.  */
		else {
			/* For personal picks, I set all numbers JTextField to null, and I will have to
			 * personally assign 6 integer values to the what I pick for lottery numbers.  */
			for (int i = 0; i < 6; i++) {
				gui.numbers[i].setText(null);;
			}
		}
	}
	
	
	/* Invoked inside the run() method's while loop.  I increment the number by 1 
	 * every time the while loop iterates, then display it on the JTextField drawings.  
	 * I also invoke this method in the switch-case block inside the run() method, 
	 * I add one to the JTextField depend on how many matches (3-6) I have.  */
	public void addOneToField(JTextField field) {
		/* Retrieve the JTextField's String, then add 0 in front of it.  In case if the
		 * field is empty, I cannot convert a null String to Integer, add 0 to it can
		 * help me to transform a null String to the integer 0.  */
		int number = Integer.parseInt("0" + field.getText());
		/* Increment number by 1.  */
		number++;
		/* Convert number to String then sets it as the field's text.  */
		field.setText(Integer.toString(number));
	}
	
	
	/* It's used for the for loop inside itemStateChanged. The do while loop will
	 * run at least once, if the condition is of this method is true again, the
	 * while loop will run again.  */
	boolean numberGone(int number, JTextField[] pastNumbers, int count) {
		/* Use for loop to check whether if the current number is equal to past numbers,
		 * because if it is, it will return true and the do-while loop will iterate
		 * again. The reason why is because lottery numbers are not the same, once they
		 * are picked, they cannot be picked again.  The do-while loop will continue to 
		 * iterate until it finds a unique number to overwrite the repeated number.  */
		for (int i = 0; i < count; i++) {
			if (Integer.parseInt(pastNumbers[i].getText()) == number) {
				/* Returns true if one of the past numbers match with the number.  */
				return true; 
			}
		}
		/* Returns false.  */
		return false;
	}
	
	
	/* win represents one of the six balls that is currently being generated by the
	 * lottery machine. allPicks is the an array of numbers that I picked.  If the 
	 * ball matches with one of the six numbers.  I return true.  */
	public boolean matchedOne(JTextField win, JTextField[] allPicks) {
		for (int i = 0; i < 6; i++) {
			String winText = win.getText();
			if (winText.equals(allPicks[i].getText())) {
				return true;
			}
		}
		/* If the ball matches with none of the JTextField from the allPicks (numbers) 
		 * JTextField, I should return false.  */
		return false;
	}
	
	
	/* The following method is generated by Runnable interface.  It contains codes that 
	 * control the event when a Thread is running.  It's invoked by the start() method.  
	 * I believe every time a drawing happens, a new thread executes, I am not sure.  */
	@Override
	public void run() {
		/* Gets the currently executing thread.  */
		Thread thisThread = Thread.currentThread();
		
		/* While playing is equal to the currently executing thread.  */
		while (playing == thisThread) {
			addOneToField(gui.drawings);
			
			/* Get the drawings in integer format.  Then use it to calculate years, then set
			 * the text of years JTextField to calculated years.  */
			int drawingsNumber = Integer.parseInt(gui.drawings.getText());
			/* I supposed there are 104 lottery drawings happened in a year, so the year 
			 * displayed is similar to the number of drawings.  */
			float yearsNumber = (float) drawingsNumber / 104;
			gui.years.setText(Float.toString(yearsNumber));
			
			/* Initialize matches as 0, a variable later use to check how many of the values
			 * in numbers JTextField(s) match with the values in winners JTextField(s).  Also, 
			 * matches will be reset to 0 for every drawing.  */
			int matches = 0;
			
			/* Similar to for loop method to generate numbers for quickpick option.  Here, 
			 * I use a for loop to generated 6 unique numbers from 1 to 50 for the winning 
			 * lottery numbers.  */
			for (int i = 0; i < 6; i++) {
				int ball;
				do {
					ball = (int) Math.floor(Math.random() * 50 + 1);
				} while (numberGone(ball, gui.winners, i));
				gui.winners[i].setText(Integer.toString(ball));
				/* Every time the for loop iterates, check if the current ball matches with the
				 * numbers I or the computer choose from the "numbers" JTextField array.  */
				if (matchedOne(gui.winners[i], gui.numbers)) {
					/* Add 1 to matches to if the above conditional statement.  */
					matches++;
				}
			}
			
			switch(matches) {
				case 3:
					/* Add one to got3 JTextField's text display if matches is 3.  */
					addOneToField(gui.got3);
					break;
				case 4:
					/* Add one to got4 JTextField, and so on...  */
					addOneToField(gui.got4);
					break;
				case 5:
					addOneToField(gui.got5);
					break;
				case 6:
					addOneToField(gui.got6);
					/* If I get all 6, I disable stop, enable play, and stop the thread.  
					 * I am not sure why this is a feature, maybe it's a case worthy to 
					 * celebrate for the player.  */
					gui.stop.setEnabled(false);
					gui.play.setEnabled(true);
					gui.reset.setEnabled(true);
					gui.quickpick.setEnabled(true);
					gui.personal.setEnabled(true);
					playing = null;
					/* No need to break because I stopped the thread.  */
			}
			
			/* Get the drawing speed from the speed JTextField.  */
			try {
				try {
					int drawSpeed = Integer.parseInt(gui.speed.getText());
					/* Draw speed can't be >10 seconds, it also can't be zero or negative.  */
					if (drawSpeed > 10000 || drawSpeed <= 0) {
						throw new Exception();
					}
					Thread.sleep(drawSpeed);
				}
				catch (Exception e) {
					/* If the draw speed is invalid, I am going to reset it to 100.  */
					gui.speed.setText("100"); 
					/* Set it so the Thread sleeps every 0.1 seconds.  */
					Thread.sleep(100);
				}
			}
			catch (InterruptedException e) {
				// Do nothing.  I don't want to interrupt the GUI.  
			}
			
		}
	}
	
}
